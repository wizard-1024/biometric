Biometric FingerPrint Software Development Kit (BFP SDK)
для Linux/Unix платформ.
	

Copyright (c) 2005-2006 Dmitry Stefankov.


Руководство разработчика.
Версия 2.3
Апрель 2007 года.


1.   Общее описание 
2.   Требования к программному обеспечению и оборудованию
3.   Состав BFP SDK
4.   Установка и применение
5.   Описание структур и функций
6.   Драйвер и конфигурационный файл bfpsdk.conf
7.   Дополнения и разъяснения
8.   Вопросы и ответы
9.   Capture Image SDK (CI-SDK)
10.  Эквивалентность BFPSDK функции и FtrScanAPI (Microsoft Windows)
11.  Некоторые замечания о программирования Futronic сканера
     для Unix и Microsoft Windows платформ


1. Общее описание 

Цель BFP SDK - использование средств биометрической аутентификации
на Unix/Linux платформах. До сегодняшнего дня применение любых
биометрических технологий в мире Unix в широком масштабе было
практически невозможно. Основными причинами этого являлись крайне
сложное и дорогое оборудование, несовершенство самих технологий,
а также перенос программного обеспечения (ПО) с платформы Microsoft
Windows в мир Unix. Стандарты и ПО для Microsoft Windows всегда были
крайне сложны, противоречивы и очень неудобны в использовании.
Однако по мере совершенствования биометрических технологий и увеличения
надежности оборудования стало возможным добиться желаемой простоты
и экономичности для биометрических решений. Теперь с появлением
такого простого и удобного пакета SDK будет наконец возможным внедрение
и эксплуатация биометрической аутентификации в мире Unix/Linux.
 


2. Требования к программному обеспечению и оборудованию

BFP SDK предназначен пока только для эксплуатации на аппаратных
платформах на базе процессора x86 фирмы Intel или совместимых
платформах.

Операционные системы для которых разрабатывался BFP SDK следующие:
ОС на базе ядра Linux (например, дистрибутивы Suse Linux, Debian Linux, 
RedHat Linux, Mandrake Linux, ASP Linux, ALT Linux, Knoppix, Slackware) 
и ОС на базе BSD 4.4 (например, FreeBSD, NetBSD, OpenBSD, Mac OS X). 
Мы поддерживаем все версии ядра Linux, начиная с версии 2.2.18
и все версии ОС FreeBSD, начиная с версии 4.9.
Также поддерживаются все версии ОС OpenBSD, начиная с версии 3.0, 
и все версии ОС NetBSD, начиная с версии 1.5.2 .
На момент написания этого рукодство текущими версиями были:
ядро Linux - 2.4.32 и 2.6.16;
ОС FreeBSD - 4.11 или 5.4 или 6.0;
ОС NetBSD - 2.1;
ОС OpenBSD - 3.8;

BFP SDK был оттестирован на следующих платформах и ОС:
1) Intel Pentium 166Mhz, 64MB ОЗУ, Intel chipset 430HX
   (Mainboard P/I-XP55T2P4), UHCI 1.0
   FreeBSD 4.11, 
   NetBSD 1.5.2,
   NetBSD 2.1;
   OpenBSD 3.8,
   Debian Linux 2.2 (kernel 2.4.14),
   Slackware Linux 10.2 (kernel 2.4.31);
2) Intel Pentium 200MHz, 64MB ОЗУ, Intel chipset 430TX 
   (Mainboard Asus TX97-XE), UHCI 1.1
   FreeBSD 4.11, 
   OpenBSD 3.0, 
   Suse Linux 6.3 (kernel 2.2.25),
   RedHat Linux 6.2 (kernel 2.2.18,2.2.25,2.4.5);
3) Intel Pentium III 2x1000Mhz, 1 GB ОЗУ, VIA Apollo Pro133A chipset
   (Mainboard 694D Pro2-IR, MS-6321 v2.X), UHCI 1.1
   (Внешний контроллер) UHCI 2.0
   FreeBSD 4.11, 
   FreeBSD 5.4,    
   FreeBSD 6.0,    
   Suse Linux 7.3 (kernel 2.4.10 - 2.4.20),
   RedHat Linux 8.0 (kernel 2.4.18),   
   RedHat Linux 9.0 (kernel 2.4.20 - 2.6.16),
   Mandrake Linux 8.1 (kernel 2.4.8),
   Mandrake Linux 9.1 (kernel 2.4.21);
   Mandrake Linux 10.0 (kernel 2.6.11);   
   Fedora Core 2 Linux (kernel 2.6.5 - 2.6.12)
   Fedora Core 5 Linux (kernel 2.6.15 - 2.6.16)   
   Knoppix 4.0.2 Live CD (kernel 2.6.12)
   ALT Linux Master 2.4
   Intel Solaris x86 9
   Intel Solaris x86 10
   QNX Momentics NC Edition 6.2.1
4) Intel Pentium III 1GHz, 512 MB memory, VIA Twister
   (Asus B1000 Series), UHCI 1.1
   FreeBSD 5.3, 
   FreeBSD 6.0,
   RedHat Linux 9.0 (kernel 2.4.20 - 2.6.1),
   Suse Linux 10.0 (kernel 2.4.13 - 2.4.15),
   Knoppix 4.0.2 Live CD (kernel 2.6.12)
5) Intel Pentium 166MHz, 32MB ОЗУ, 
   (Toshiba Satellite Pro 460CDT), OHCI 1.0
   FreeBSD 4.11, 
   FreeBSD 5.3 
6) Mac mini, Intel Core Solo 1.5GHz, 512 MB memory, ICH7
   AppleUSBUHCI v2.0
   Mac OS X 10.4.4 (Darwin kernel 8.5.3)


Сейчас в BFP SDK поддерживается в качестве аппаратного обеспечения
только биометрический сканер отпечатков пальцев фирмы Futronic 
с интерфейсом USB. Следующие модели сканеров от Futronic поддерживаются:
FS80 (c интерфейсом USB 1.1 или USB 2.0), FS82.

В составе BFP SDK нет драйвера для сканера (т.наз. kernel mode driver). 
При правильном проектировании аппаратного обеспечения для данной задачи
он не нужен. Интерфейс USB обладает режимом передачи неструктурированного
массива данных. Этого достаточно для работы с USB устройством из
пользовательского режима (user mode). BFP SDK полагается здесь на
широко распространенную многоплатформенную библиотеку libusb.
Последняя версия libusb - 0.1.11 (на момент создания BFP SDK). Именно 
эта версия рекомендуется для установки и использования совместно с BFP SDK. 
Официальный сайт этой библиотеки - http://libusb.sourceforge.net.
После установки этой библиотеки не забудьте обновить кеш для
динамических библиотек (для помощи: man ldconfig).

Примечание: см. также 6 (драйвер).



3. Состав BFP SDK

BFP SDK включает в себя следующие файлы:

bfpsdk-x.y.z.tar.gz  -  собственно весь комлект ПО для BFP SDK,
                        где x.y.z - это номер версии.

bfpsdk.so        -  динамически подгружаемая библиотека
                    BFP SDK для приложений
libbfpsdk.a      -  библиотека BFP SDK для статической сборки приложений
bfpsdk.h         -  включаемый файл объявлений и определений 
                    BFP SDK для приложений
bfpsdk.mak       -  makefile для установки/удаления BFP SDK библиотеки
                    в систему, сборка/удаление примеров

sample.c         -  базовый текст для применения BFP SDK
                    Содержит стандартный код для примения BFP SDK.
                    Включает получение изображений со сканера,
                    построение темплейта и модели по этим изображениям,
                    сравнение темплейта и модели.
sample.mak       -  makefile для сборки примера sample
sample           -  скомпилированный код для вашей платформы

text-demo.c      -  демонстрационный пример применения BFP SDK
                    для работы с базой пользовательских биометрических
                    темплейтов. Полностью показывает все возможности
                    BFP SDK. Реализованы все стандартые функции
                    биометрической аутентификации 
                    (enrollment/identification/verification).
                    Простой текстовой интерфейс для любой среды
                    Linux/Unix (даже без curses).
text-demo.mak    -  makefile для сборки примера text-demo
text-demo        -  скомпилированный код для вашей платформы

ncurses-demo.c   -  функционально идентичен text-demo
                    Текстовой пользовательский интерфейс 
                    базируется на библиотеке curses.
ncurses-demo.mak -  makefile для сборки примера ncurses-demo
ncurses-demo     -  скомпилированный код для вашей платформы

gtk-demo.c       -  функционально идентичен text-demo
                    Графический интерфейс для GNOME/GTK2+.
                    Также должен быть установлен пакет ImagePick.
gtk-demo.mak     -  makefile для сборки примера gtk-demo
gtk-demo         -  скомпилированный код для вашей платформы
logo.png         -  легко узнаваемый образ ("penguin")
fp-off.png       -  графический образ ("уберите палец")
fp-on.png        -  графический образ ("приложите палец")

Примечание.
Все примеры по умолчанию поддерживают реентерабельые вызовы.
Для отключения реентерабельности установите директиву _REENTRANT_CALLS в 0.



4. Установка и применение

Порядок установки:

а) Скопируйте BFP SDK в какой-либо каталог, например, /usr/local/src/bfpsdk
б) Разверните библиотеку:  
  # tar xzf bfpsdk.tar.gz  
в) Установите BFP SDK в систему
  # make -f bfpsdk.mak install
  (Для удаления BFP SDK из системы используйте uninstall вместо install)
г) Необязательно. Как собрать примеры из библиотеки?
   # make -f sample.mak
   # make -f text-demo.mak
   # make -f ncurses-demo.mak
   # make -f gtk-demo.mak
Для удаления используйте те же команды, но с параметром clean.

Порядок применения.

Теперь вы можете использовать BFP SDK в своих приложениях.
а) В текст приложения должна быть добавлена строка:
  #include <bfpsdk.h>
б) При компиляции должно быть добавлено:
  -I/usr/local/include
в) При сборке должно быть добавлено:
  /usr/lib/bfpsdk.so или просто bfpsdk.so
г) Для статической сборки нужно добавить следующее:
   -static -lbfpsdk  
Cмотрите для уточнения исходный текст примеров из BFP SDK.



5. Описание структур и функций

Структуры.

В BFP SDK определены две следующие структуры - 
bfp_hardware_info и bfp_software_info.

Структура bfp_hardware_info хранит описание аппаратных особенностей
каждого сканера. Для прикладного программиста интересен только
серийный номер сканер.

Структура bfp_software_info содержит необходимые величины и константы,
делающие код прикладной программы, независимым от особенностей реализации
библиотеки BFP SDK (аппаратной части и математического алгоритма для
работы с отпечатками пальцев).
Необходимые поля прикладному программисту следующие:
model_size   -- размер модели (в байтах)
total_size   -- размер темплейта (в байтах) 
measure      -- мера сравнения (порог узнавания или пропуска)
image_size   -- размер изображения (в байтах)
samples_num  -- число изображений для построения темплейта
models_num   -- минимальное число моделей для темплейта
max_models   -- максимальное число моделей для темплейта
bfp_get_image_timeo_r_size  -- размер временного пространства для соотв. функции 
bfp_extract_r_size          -- размер временного пространства для соотв. функции 
license_info -- информация о Вашей лизенции
hardware_access_info -- информация о методах доступа к оборудованию

Правильное использование этих структур можно найти в демонстрационных
примерах BFP SDK. Обязательно посмотрите этот код из BFP SDK, 
прежде чем разрабатывать свой код.


Функции. 

Название                   Назначение
---------------------      ---------------------------------------
bfp_init                   подключить библиотеку
bfp_deinit                 отключить библиотеку
bfp_get_software_info      вернуть параметры библиотеки 
bfp_get_hardware_info      вернуть параметры оборудования
bfp_get_image_timeo        получить изображение с отпечатком пальца
bfp_get_image_timeo_r      получить изображение с отпечатком пальца
bfp_extract                построить темплейт/модель
bfp_extract_r              построить темплейт/модель
bfp_match                  сравнить темплейт/модель


----------------

Инициализация библиотеки BFP SDK.
int bfp_init();

Возвращаемые значения: 0 = успешно, -1 = ошибка

Вызывается самой первой. Если инициализация прошла успешно, то можно
продолжать работу. В противном случае необходимо завершить работу
приложения.


----------------

Завершение работы библиотеки BFP SDK.
int bfp_deinit();

Возвращаемые значения: 0 = успешно
Вызывается самой последней. После ее вызова работа с BFP SDK уже 
невозможна.


----------------

Получить значения констант библиотеки BFP SDK.
int bfp_get_software_info( struct bfp_software_info * p_soft_param );

Параметры:
struct bfp_software_info * p_soft_param  -- указатель на буфер для заполнения

Возвращаемые значения: 0 = успешно, -1 = ошибка

Прикладной программист передает указатель на структуру bfp_software_info
и после вызова можно применить найденные значения в этой структуре для
корректной инициализации других объектов в прикладной программе.
Рекомендуется вызывать эту функции после bfp_init(), хотя она может быть
вызвана в любой момент времени.  
Эта функция реентерабельна.


----------------

Получить описание BFP сканера, подключенного к системе.
int bfp_get_hardware_info( struct bfp_hardware_info * p_hard_param, int scanner );

Параметры:
struct bfp_hardware_info * p_hard_param  -- указатель на буфер для заполнения
int scanner  -- порядковое число сканера (только для подсчета)

Возвращаемые значения: 0 = успешно, -1 = ошибка, -2 = нет сканера

Прикладной программист передает указатель на структуру bfp_hardware_info
и порядковое число сканера. Меняя это число от 0 до N вы можете
подсчитать число сканеров в системе. Однако, необходимо где-то
запомнить серийные номера этих сканеров, потому что если к системе
подключено несколько сканеров, то иного способа при получении изображения
их различать нет. Используя эту функцию с числом 0 всегда можно
убедиться, что есть как минимум один подключенный сканер.
Эта функция реентерабельна.


----------------

Получить изображение отпечатка пальца с BFP сканера.
int bfp_get_image_timeo( unsigned char * buf, unsigned long int bufsize, 
                         int timeout, unsigned long int sernum,
			 unsigned long int options );
int bfp_get_image_timeo_r( unsigned char * buf, unsigned long int bufsize, 
                           int timeout, unsigned long int sernum,
		           unsigned char * raw_images_buf, 
		           unsigned long int raw_images_bufsize,
			   unsigned long int options );

Параметры:
unsigned char * buf  -- буфер для запоминания изображения
unsigned long int bufsize  -- размер буфера
int timeout  -- время ожидания для получения отпечатка пальца (в сеkундах)
                0 = считать изображение без ожидания
unsigned long int sernum  -- серийный номер сканера
                             0 = использовать первый найденный сканер в системе  
unsigned char * raw_images_buf  -- временный буфер 
                                   NULL = не использовать
unsigned long int raw_images_bufsize  -- размер временного буфера
                                  если меньше чем значение поля
                                  bfp_get_image_timeo_r_size
                                  из структуры bfp_software_info, то не
                                  будет использоваться
unsigned long int options  --  специальные флаги 
                               1=Live Finger Detection
			       2Зst Finger Detect 

Возвращаемые значения: 0 = успешно, -1 = ошибка

Эта функция завершается успешно, только если изображение содержит
действительно отпечаток пальца, в остальных случаях всегда будет возвращена
ошибка. При значении timeout отличного от нуля сканер опрашивается 
в среднем раз в секунду для получения изображения.
Функция bfp_get_image_timeo() использует статические буфера, поэтому она 
нереентерабельна.
Реентерабельная функция bfp_get_image_timeo_r() нуждается во временном 
пространстве. Необходимое значение для размера буфера нужно получить из поля
bfp_get_image_timeo_r_size используя структуру bfp_software_info,
заполненной при вызове функции bfp_get_software_info().


----------------

Построение биометрической модели/темплейта по изображению(-ям).
int bfp_extract(void *images, int n, void *buf);
int bfp_extract_r(void *images, int n, void *buf,
                  void *user_space, unsigned long int space_size);

Параметры:
void *images  -- буфер содержащий от 1 до n изображений
int n         -- число изображений
                 (если 1=построить модель, >1=построить темплейт)
void *buf     -- буфер для запоминания данных модели или темплейта
                 (размер буфера должен достаточным, иначе
                  приложение будет завершено обычно по SEGV)
void *user_space  -- временный буфер  (NULL = не использовать)
unsigned long int space_size  --  размер временного буфера

Возвращаемые значения: -2 = неверные параметры, -1 = ошибка, 
                       >0=размер возвращаемых данных (успешно завершение)

Прикладной программист должен передать корректные параметры для успешного
построения модели/темплейта. Примеры правильного использования этой
функции можно посмотреть в демонстрационных текстах BFP SDK. 
Размеры буферов вычисляются следующим образом:
для изображений - размер_изображения * число_изображений;
для биометрический данных - размер модели/темплейта (взять значения
из структруры, полученной при вызове функции bfp_get_software_info.
Функция bfp_extract() использует статические буфера, поэтому она 
нереентерабельна.
Реентерабельная функция bfp_extract_r() нуждается во временном 
пространстве. Необходимое значение для размера буфера нужно получить из поля
bfp_extract_r_size используя структуру bfp_software_info,
заполненной при вызове функции bfp_get_software_info().


----------------

Сравнение темплейтов и моделей.
int bfp_match(void *buf1, int n1, void *buf2, int n2);

Параметры:
void *buf1  -- буфер для данных модели/темплейта
int n1      -- размер модели/темплейта в первом буфере (в байтах)
void *buf2  -- буфер для данных модели/темплейта
int n2      -- размер модели/темплейта в втором буфере (в байтах)

Возвращаемые значения: -2 = неверные параметры, -1 = ошибка, 
                       [0..1000] = величина меры совпадения (успешно завершение)
                       Чем ближе это число к 1000, тем более совпадают
                       предъявленные биометрические характеристики.
                       Рекомендуемый порог равен 300, а еще лучше 600. 

Прикладной программист должен передать корректные параметры для успешного
сравнения модели/темплейта. Примеры правильного использования этой
функции можно посмотреть в демонстрационных текстах BFP SDK. 
Как правильно вычислить размеры буферов смотрите выше в описании 
функции bfp_extract.
Эта функция реентерабельна.



6. Драйвер и конфигурационный файл bfpsdk.conf

Для некоторых конфигураций ОС и оборудования библиотека libusb
может работать не очень корректно. В этом случае рекомендуется
установить драйвер, релизованный в виде модуля ядра. Для ОС FreeBSD
это модуль uscan_bfp. Для ядра Linux это модуль uscanner (для 
всех версий ядра - 2.2.X,2.4.X,2.6.X).
Драйвер поставляется по запросу, в исходных текстах и без поддержки.
Вы должны будете собрать и установить модуль самостоятельно для своей 
платформы и ОС. Для сборки достаточно выполнить make.

Для переключения работы BFP SDK между библиотекой libusb и драйвером
используйте конфигурационный файл bfpsdk.conf. Этот файл должен быть
скопирован в каталог /usr/local/etc.

Следующие директивы определены и используются:

use_libusb=[0|1] 
(0=использовать драйвер, 1=использовать  libusb)

use_multi_devices=[0|1] 
(Если выбрано использовать драйвер, то при включении это директивы в 1,
можно использовать несколько устройств, заданных при помощи 
директив device_name_x, где x может меняться от 0 до 15) 

device_name_0="/dev/uscanner0" 
(для ОС Linux используйте /dev/usb/scanner0, см. текст uscanner как
 создать это устройство и подключить,
 для ОС FreeBSD используйте /dev/uscanner0 и отключите uscanner в ядре,
 если Вам нужен модуль uscanner, то модифицируйте код для поддержки 
 Вашего устройства)

#usb_device_vendor_id=xxxx 
#usb_device_product_id=yyyy 
(использовать также заданные пользователем значения для USB устройства
дополнительно ко встроенной таблице поддерживаемых устройств)

print_error_messages=[0|1] 
(0=выключить, 1=включить; 
печатать сообщения об ошибках в отладочной версии SDK)

fast_match=0
(0=выключить, 1=включить; 
быстрое сравнение, остановка на первой совпадении моделей если
уровень меры был превышен)

samples_num=N
(число изображений запрашиваемых в ходе обучения, заметим, что
пользовательская программа может использовать любое число иозображений
для обучения, данная величина - это устанавливаемый параметр для библиотеки)



7. Дополнения

Ограничения.

A) Текущая реализация
В текущей реализации BFP SDK следующие функции являются нереентерабельными:

Название                Причина
-------------------     ---------------------------------------------
bfp_get_image_timeo     использование глобальных статических данных
bfp_extract             использование глобальных статических данных

При использовании этих функций в многопоточных и параллельных приложениях
рекомендуется применять собственные алгоритмы и дисциплины порядка
доступа/блокировки/ожидания.

В BFP SDK такие алгоритмы/дисциплины не будут встроены, чтобы согласно
заветам отцов-основателей Unix не увеличивать бездумно сложность ПО 
на каждом уровне.

Вы можете использовать соответствующие xxx_r аналоги для этих
функций (bfp_get_image_timeo_r,bfp_extract_r). Суффикс _r означает поддержку
реентерабельности. Для корректного использования xxx_r функций необходимо 
выделить временное пространство указанного объема 
(из функции bfp_get_software_info), в противном случае функция вернет ошибку. 
Пространство может быть выделено где угодно - стек, куча, локальные или 
глобальные данные.


Б) Дисциплина программирования
В функциях BFP SDK есть минимальная проверка входных параметров,
однако все остальное целиком на совести прикладного программиста.
Неверные размеры буферов и т.д. будут приводить к фатальному
завершению работы BFP SDK. Несмотря на удивительную простоту функций
от программиста требуется аккуратность и внимательность при их
использовании. Не стесняйтесь заимствовать код из примеров BFP SDK,
так как данный код прежде всего именно для этого и предназначен.




8. Вопросы и ответы

Общее замечание.
Думайте и читайте. И еще раз думайте. В мире Unix без этого не прожить.

В.8.0  У меня все не работает. Что можете сказать?
В.8.1  У меня в системе не работает сканер FS82.
В.8.2  Что такое BFPSDK1 и BFPSDK2?
В.8.3  Как лицензировать BFPSDK2?
В.8.4  На какие платформы и ОС полностью или частично был перенесен BFPSDK?
В.8.5  У меня есть биометрический сканер не от Futronic. Могу ли я
       использовать его с BFPSDK?
В.8.6  Вопрос. Какий метод доступа (libusb,драйвер) к оборудованию Вы рекомендуете?
В.8.7  Будет ли поддержка BIOAPI в BFPSDK?
В.8.8  Как нужно написать Вам о проблеме? Есть ли стандартная форма?
В.8.9  Иногда не работают приложения gtk-scan и gtk-demo, а текстовые примеры
       работают замечательно. В чем может быть причина?
В.8.10 Совместимы ли между собой Windows SDK и Linux/Unix SDK?
В.8.11 Есть ли поддержка FtrScanAPI функций для Unix?
В.8.12 Поддерживается ли опция "живой"-"неживой" (LiveFingerDetection)?


8.0 
Вопрос. У меня все не работает. Что можете сказать?
Ответ. Ничего. Мои ответы начинаются с проблем при использованин пакета BFPSDK.
Вначале пришлите мне ваши системные журналы (dmesg или иначе).
Когда я увижу, что сканер успешно подключается к Вашей ОС, тогда
будем думать над проблемой. Замечу, что Ваша ОС должна распознавать
Futronic сканер без BFPSDK или драйверов из BFPSDK. 


8.1 
Вопрос. У меня в системе не работает сканер FS82.
Ответ. Сканер FS82 требует мощности на порт более 500мА. Такую мощность
можно получить только на USB-корневых хабах (USB-root hubs) или на USB 
хабах с автономным питанием. В остальных случаях на порт выделяется мощность
в 100 мА, что недостаточно для сканера FS82.


8.2
Вопрос. Что такое BFPSDK1 и BFPSDK2?
Ответ. BFPSDK1 - это BFPSDK v1.3. BFPSDK2 - это BFPSDK 2.0.
BFPSDK1 распространяется свободно (некоммерческая версия). Базируется
на алгоритме 2004 года. Поддерживает сканеры FS80 с USB 1.1 (с kernel module
и libusb). Другие модели (FS80-USB2 или FS82) поддерживаются только с 
использованием kernel modules. Расширенные возможности новых сканеров не
поддерживаются. Нет поддержки реентерабельности.
BFPSDK2 является коммерческой лицензируемой версией, т.е. не
распространяется свободно. Базируется на алгоритме 2006 года. Поддерживает 
все Futronic сканеры FS80-USB1/USB2,FS82 (с kernel module и libusb). 
Расширенные возможности новых сканеров поддерживаются. Есть поддержка 
реентерабельности.
Каждая новая версия биометрического аолгоритма обязательно имеет следующие 
улучшения: улучшение качества работы, особенно с "трудными пальцами",
увеличение скорости работы.
В BFPSDK2 для новых сканеров используются улучшенный метод "снятия
изображения".


8.3
Вопрос. Как лицензировать BFPSDK2?
Ответ. Напишете мне или в Futronic. Нужно будет прежде всего описание вашей
платформы и ОС (или нескольких). После определения технической возможности
переноса BFPSDK2 на Вашу платформу или ОС, можно будет рассчитать стоимость
лизенции. Лицензионная плата - одноразовая, без ограничений на количество
рабочих мест с поддержкой по электронной почте в течении одного года. 
Стоимость расширенной поддержки оплачивается отдельно.


8.4
Вопрос. На какие платформы и ОС полностью или частично был перенесен BFPSDK?
Ответ. Основная платформа - x86 системы. На ARM9 использовался kernel module.
Cписок ОС:
BSD(x86): FreeBSD (полностью), OpenBSD (полностью), NetBSD (полностью)
Linux(x86): RedHat (полностью), Suse (полностью), Debian (полностью), 
       Mandrake (полностью), ASP (полностью), ALT (полностью), 
       Knoppix (полностью), Fedora Core (полностью), 
Solaris(x86): 9 и 10 (частично, нет драйвера, использовался сетевой сканер)
QNX (x86): 6.2.1 (частично, нет драйвера, использовался сетевой сканер)
Mac OS OX: 10.4.5 (польностью)


8.5
Вопрос. У меня есть биометрический сканер не от Futronic. Могу ли я
использовать его с BFPSDK?
Ответ. Не можете. И не стоит пытаться. Хотя до Вас это уже пробовали не один
раз.


8.6
Вопрос. Какий метод доступа (libusb,драйвер) к оборудованию Вы рекомендуете?
Ответ.
Для старых ОС лучше libusb. Для всех новейших ОС желательно использовать 
драйвер ядра.
BFPSDK может использовать следующие методы доступа к оборудованию:
1) libusb - использование библиотеки libusb.
Межплатформенная независимость. Плохо работает с некоторыми USB 2.0 
картами-контроллерами. Требует расширенных прав от пользователя для доступа 
к оборудованию. Плохо с диагностикой и отладкой.
2) устройство ugen - использование системного драйвера для устройство ugen.
Может использоваться только если системный драйвер поддерживает
неструктурированную блочную передачу данных.
3) специализированный драйвер ядра (FreeBSD,Linux)
Есть возможность детальной диагностики и отладки (ключ debug=1).


8.7
Вопрос. Будет ли поддержка BIOAPI в BFPSDK?
Ответ. BFPSDK можно использовать для написания соответствующих компонент в
BIOAPI. Пока не планируется.


8.8
Вопрос. Как нужно написать Вам о проблеме? Есть ли стандартная форма?
Ответ. Форма свободная. Используйте здравый смысл и понимание того,
что я не сижу рядом с Вами и все что у меня есть - это Ваше описание ситуации.
Неправильный вариант (реальный, из компании B.).
"Функция bfp_get_hardware_info возвращает -1. Что посоветуете?"
Ну, что можно сказать таким людям ...
Правильный вариант.
"У меня ОС X.Y.Z, ядро A.B.C, BFPSDK версии N для платформы M. Установил.
Внес или не внес изменения в bfpsdk.conf (можно даже его прислать, 
нужно также указать какие методы доступа используете). Сканер определяется 
в системе следующим образом (можно прислать кусочек или весь dmesg). Если 
сканер не определяется системой (нужно присылать весь dmesg). При использовании
функции bfp_get_hardware_info всегда получаю значение -1. Что посоветуете 
предпринять?"
Заметим, что это стандартные требования в любой хорошей службе технической
поддержке.
У меня будут начальные сведения по Вашей проблеме и можно будет что-то делать.


8.9
Вопрос. Иногда не работают приложения gtk-scan и gtk-demo, а текстовые примеры
работают замечательно. В чем может быть причина?
Ответ. Примеры gtk-scan и gtk-demo используют множество графических библиотек.
Они также используют очень агрессивный метод обновления экрана, что не любят
некоторые видеоадаптеры. Попробуйте выполнить эти примеры на компьютере с 
другим видеоадаптером. Планируется написать новый примеры xdemo и xscan с той 
же функциональностью, однако с использованием только Xlib и XToolkit.


8.10 
Вопрос. Совместимы ли между собой Windows SDK и Linux/Unix SDK?
Ответ. Windows SDK и Linux/Unix SDK используют один и тот же алгоритм, поэтому
они должны быть совместимы между собой. Однако разработчики Windows SDK 
добавляют лишние 3 байта при хранении темплайтов/моделей (2 байта - длина, 
1 байт - число моделей). Вы должны учитывать это при разработке ваших 
приложений, если будет использовать вместе Window SDK и Linux/Unix SDK.


8.11 
Вопрос. Есть ли поддержка FtrScanAPI функций для Unix?
Ответ. Начиная с версии BFPSDK 2.1 (CI-SDK также) существует поддержка
практически всех функций FtrScanAPI для Unix платформ. Это позволяет 
использовать один и тот же код для Windows и Unix. Однако при использовании
функций FtrScanAPI на Unix платформах пока можно работать только с одним 
сканером. Документацию для FtrScanAPI можно получить, обратившись в
Futronic.



8.12 
Вопрос. Поддерживается ли опция "живой"-"неживой" (LiveFingerDetection)?
Ответ. BFPSDK/CISDK имеет по умолчанию достаточно хороший алгоритм для борьбы
с муляжами. Однако, если SDK включает в себя функции FtrScanAPI, то при
считывании отпечатка в функциях bfp_get_image_timeo и bfp_get_image_timeo_r
можно включать опцию LFD ("живой"/"неживой").





9. Capture Image SDK (CI-SDK)

Capture Image SDK (CI-SDK) может использоваться теми разработчиками,
кто нуждается только в работе со сканером для захвата изображения и
планирует использовать собственные биометрические алгоритмы. Данный SDK
следует той же идеологии простоы и унниверсальности как BFPSDK. В составе
CI-SDK есть демонстрационные примеры. CI-SDK поставляется в двух вариантах:
1) как дополнение в составе пакета BFPSDK;
2) как отдельный пакет независимо от пакета BFPSDK;

Следующие демонстрационные примеры входят в состав CI-SDK:

ci-get-raw-image           --  считать "сырое" изображение с использованием
                               дозы подсветки
ci-get-diodes-state        --  получить текущее состояние "красного" и 
                               "зеленого" диодов
ci-set-diodes-state        --  установить новое состояние "красного" и 
                               "зеленого" диодов
ci-get-fp-image            --  считать изображение отпечатка
ci-get-fp-image-lfd        --  считать изображение отпечатка с включенной опцией
                               "живой"/"неживой" (LFD)


Функции. 

Название                   Назначение
---------------------      ---------------------------------------
ci_get_image_size          получить размер изображения
ci_get_raw_image           считать "сырое" изображения с использованием
                           команд подсветки (доза света)
ci_get_diodes_state        веруть текущее состояние диодов свечения
ci_set_diodes_state        установить новое состояние диодов свечения
bfp_get_image_timeo        считать изображение "отпечатка"
bfp_get_image_timeo_r      считать изображение "отпечатка" 
                           (реентерабельный вариант)


Детальное описание каждой функции.


----------------

Получить размер памяти для одного изображения.
unsigned long int ci_get_image_size( void );

Параметры:
Нет.

Возвращаемые значения:  размер изображения (в байтах)

Данная функция дает простейший способ получить величину объема памяти
для одного изображения.
Эта функция реентерабельна.


----------------

Считать "сырое" изображения с использованием команд подсветки (доза света).
int ci_get_raw_image( const unsigned char cmd_op, unsigned char * buf, 
                      unsigned long int bufsize, unsigned long int sernum );

Параметры:
const unsigned char cmd_op - номер дозы подсветки (0-4)
unsigned char * buf - буфер для записи изображения
unsigned long int bufsize - размер буфера в байтах
unsigned long int sernum  - серийный номер сканера (0=первый найденный)

Возвращаемые значения: 0 = успешно, <0 = ошибка

Функция считывает изображение, полученное на сканере, независимо от того,
был ли приложен палец или нет. Изображение может быть подсвечено с
использованием команды дозы (cmd_op). Доза 0 - это отсутствие подсветки
вообще. Дозы с 1 по 4 - это включение подсветки (1=минимальная, 
4=максимальная). Программист должен сам выбрать желаемые дозы для работы.
Размер буфера должен быть не меньше величины, полученной при помощи функции
ci_get_image_size(). Внутри функции есть минимальные проверки для допустимых
значений ее параметров.
Эта функция реентерабельна.


----------------

Веруть текущее состояние диодов свечения.
int ci_get_diodes_state( unsigned char * green_diode, unsigned char * red_diode,
                         unsigned long int sernum );

Параметры:
unsigned char * green_diode - указатель на переменную для запоминания 
                              текущего состояния "зеленого света"
                              (0=выкл., 1=вкл.)
unsigned char * red_diode   - указатель на переменную для запоминания 
                              текущего состояния "красного света"
                              (0=выкл., 1=вкл.)
unsigned long int sernum    - серийный номер сканера (0=первый найденный)

Возвращаемые значения: 0 = успешно, <0 = ошибка

Данная функция возвращает состояние диодов свечения (зеленого и красного).
Эта функция реентерабельна.


----------------

Установить новое состояние диодов свечения.
int ci_set_diodes_state( unsigned char green_diode, unsigned char red_diode, 
                         unsigned long int sernum );

Параметры:
unsigned char green_diode   - новая величина для диода "зеленого света"
                              (0=выкл., 255=вкл., 1-254=включить на интервал
                              в 10-ти мс единицах)
unsigned char red_diode     - новая величина для диода "красного света"
                              (0=выкл., 255=вкл., 1-254=включить на интервал
                              в 10-ти мс единицах)
unsigned long int sernum    - серийный номер сканера (0=первый найденный)

Возвращаемые значения: 0 = успешно, <0 = ошибка

Данная функция устанавливает новое состояние диодов свечения (зеленого и 
красного). Величина 255 включает диод лишь на несколько секунд, а не
навсегда (такова аппаратная релизация). 
Эта функция реентерабельна.




10.  Эквивалентность BFPSDK функции и FtrScanAPI (Microsoft Windows)

Ниже можно найти список FtrScanAPI функций и их функционально
эквивалентные функции из BFPSDK.


----------------

Функция:    ftrScanOpenDevice
Назначение: Открыть устройство.
BFPSDK:     Реализовано внутри для соответствующей функции.


----------------

Функция:     ftrScanCloseDevice
Назначение:  Закрыть устройство.
BFPSDK:      Реализовано внутри для соответствующей функции.


----------------

Функция:     ftrScanGetInterfaces
Назначение:  Состояние устройста для всех интерфейсов.
BFPSDK:      bfp_get_hardware_info


----------------

Функция:     ftrSetBaseInterface
Назначение:  Установить номер интерфейса по умолчанию.
BFPSDK:      Реализовано внутри для соответствующей функции.


----------------

Функция:     ftrGetBaseInterfaceNumber
Назначение:  Вернуть номер интерфейса по умолчанию.
BFPSDK:      Реализовано внутри для соответствующей функции.


----------------

Функция:     ftrScanOpenDeviceOnInterface
Назначение:  Открыть устройство для выбранного интерфейса.
BFPSDK:      Реализовано внутри для соответствующей функции.


----------------

Функция:     ftrScanSetOptions
Назначение:  Установить опции.
BFPSDK:      Internally implemented in bfp_get_image_timeo,bfp_get_image_timeo_r


----------------

Функция:     ftrScanGetOptions
Назначение:  Вернуть опции.
BFPSDK:      bfp_get_image_timeo,bfp_get_image_timeo_r


----------------

Функция:     ftrScanGetDeviceInfo
Назначение:  Информация об устройстве.
BFPSDK:      bfp_get_hardware_info


----------------

Функция:     ftrScanGetImageSize
Назначение:  Размер изображения.
BFPSDK:      ci_get_image_size, bfp_get_software_info


----------------

Функция:     ftrScanGetImage
Назначение:  Считать "сырое" изображение.
BFPSDK:      ci_get_raw_image


----------------

Функция:     ftrScanGetDarkImage
Назначение:  Считать "сырое" изображение без подсветки.
BFPSDK:      ci_get_raw_image with CI_READ_IMAGE_ON_DOSE_0


----------------

Функция:      ftrScanIsFingerPresent
Назначение:   Есть ли палец на устройстве.
BFPSDK:       bfp_get_image_timeo,bfp_get_image_timeo_r


----------------

Функция:     ftrScanGetFrame
Назначение:  The function captures a fingerprint frame from the device.
BFPSDK:      bfp_get_image_timeo, bfp_get_image_timeo_r


----------------

Функция:     ftrScanSave7Bytes
Назначение:  Запоминает 7-байтовый буфер на устройстве.
BFPSDK:      bfp_set_device_sernum


----------------

Функция:     ftrScanRestore7Bytes
Назначение:  Восстанавливает 7-байтовый буфер с устройства.
BFPSDK:      bfp_get_device_sernum


----------------

Функция:     ftrScanSetNewAuthorizationCode
Назначение:  Устанавливает код авторизаци для ftrScanSaveSecret7Bytes/ftrScanRestoreSecret7Bytes.
BFPSDK:      Не релизовано


----------------

Функция: ftrScanSaveSecret7Bytes
Назначение:  Запоминает 7-байтовый буфер на устройстве.
BFPSDK:      Не релизовано


----------------

Функция:     ftrScanRestoreSecret7Bytes
Назначение:  Восстанавливает 7-байтовый буфер с устройства.
BFPSDK:      Не релизовано


----------------

Функция:     ftrScanSetDiodesStatus
Назначение:  Устанваливает новое состояние светодиодов.
BFPSDK:      ci_set_diodes_state


----------------

Функция:     ftrScanGetDiodesStatus
Назначение:  Возвращает состояние светодиодов.
BFPSDK:      ci_get_diodes_state



11.  Некоторые замечания о программирования Futronic сканера
     для Unix и Microsoft Windows платформ


11.1  Опция защиты команды при исполнении.

Futronic сканер имеет встроенную опцию защиты при исполнении команды.
Это означает что после получения команды firmware сканера запускает
внутренний сторожевой таймер (watchdog timer) для контроля истечения
временного интервала для исполнения команды на фазе передачи данных. 
Если данные переданы до истечения временного интервала, то таймер
останавливается. Если полной передачи не произошло до истечения 
временного интервала, тогда firmware отсоединяет устройство от USB шины,
ждет некоторое время и затем вновь присоединяет устройство к USB шине.
Это практически эквивалентно ручному методу: отсоединить устройство
от USB порта, а затем вновь его подключить к USB порту.
Данная опция была добавлена по следующим причинам:
(1) проблемы прикладного ПО
    (например, программист забывает считать полностью блок данных, т.е.
     все изображение)
(2) проблемы системного ПО
    (многие операционные системы имеют разные реализации USB стека,
     которые имеют разнообразные ошибки и недостатки)    


11.2. Сериализация доступа к USB сканеру

Любой доступ к USB сканеру должен быть сериализован. Firmware сканера
не имеет внутренной очереди команд и может исполнять только одну команду
в любой момент времени. Поэтому прикладные и системные программисты должны
разработать соответствующую дисциплину (порядок) для доступа к оборудованию
из системного или прикладного программного обеспечения. Например, для
Microsoft Windows платформы рекомендуется использовать мьютексы (двоичные
семафоры). На Unix платформах можно использовать System V или Posix
семафоры. Такая техника будет гарантированно сериализовать доступ к
оборудованию из различных приложений или частей приложения (например,
потоков - threads).



11.3. Многопоточные приложения (multi-threaded applications)

Если биометрический SDK не имеет эффективной сериализации доступа к
устройству, тогда приложение должно использовать собственную дисциплину
порядка доступа к сканеру. Такая дисциплина будет препятствовать
одновременному доступу к устройству из нескольких потоков.
Например, Unix/Linux SDK не имеет такой блокирующей дисциплины и поэтому 
прикладные программисты должны использовать собственную дисциплину запросов
к сканеру (обычно это чтение изображения). Программист может применить
стандартные Posix семафоры для построения своей дисциплины.
(В Unix SDK 1.x,2.x смотри "7. Дополнения и разъяснения" для некоторых
деталей)
Если вы разрабатываете и также тестируете свои приложения без такой
дисциплины доступа, то вы всегда будете видеть странное поведение вашего
кода обусловленное одновременным доступом к оборудованию из нескольких
потоков (commands meshing - смешение команд) и, может быть, некорректной
временной синхронизацией между частями программы, и частичным чтением данных
вместо полного чтения данных.



11.4. Параллельные приложения (parallel applications)

Такие же соображения могут быть использованы для параллельных приложений как
и для многопоточных приложений потому что природы доступа к оборудованию
одна и та же.

